<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº‘å‰ªè´´æ¿</title>
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.3/css/bootstrap.min.css" rel="stylesheet">
    <style>
        :root {
            --success: #28a745;
            --danger: #dc3545;
            --primary: #007bff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #f8f9fa;
            min-height: 100vh;
        }

        .drag-over {
            border: 2px dashed var(--primary) !important;
            background-color: rgba(0, 123, 255, 0.05);
        }

        .file-card {
            transition: transform 0.2s, box-shadow 0.2s;
            min-height: 300px;
        }

        .file-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
        }

        .content-preview {
            position: relative;
            max-height: none;
            overflow: visible;
        }

        .whitelist-icon {
            width: 18px;
            height: 18px;
            margin-right: 6px;
        }

        #toast {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .pre-line {
            transition: max-height 0.3s ease;
            white-space: pre-wrap;
            word-break: break-word;
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 4px;
            font-family: monospace;
            line-height: 1.5;
            overflow-x: auto;
        }

        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            z-index: 20;
            opacity: 0.7;
            transition: opacity 0.2s;
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
        }

        .copy-btn:hover {
            opacity: 1;
            background-color: #f8f9fa;
        }

        .text-content-wrapper {
            position: relative;
        }

        .copy-success {
            background-color: var(--success) !important;
            color: white !important;
            border-color: var(--success) !important;
        }

        .drop-zone-text {
            transition: all 0.3s;
        }

        .drop-zone-hint {
            font-size: 0.85rem;
            margin-top: 8px;
            color: #6c757d;
        }

        .key-management {
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .progress-container {
            margin-top: 10px;
        }

        .chunk-progress {
            height: 8px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div class="container py-4">
    <!-- AESå¯†é’¥ç®¡ç†åŒºåŸŸ -->
    <div class="key-management">
        <h5 class="mb-3">ğŸ”‘ AESå¯†é’¥ç®¡ç†</h5>
        <div class="mb-3">
            <label class="form-label">åŠ å¯†å¯†é’¥</label>
            <input type="password" id="aesKeyInput" class="form-control" placeholder="è¾“å…¥AESåŠ å¯†å¯†é’¥">
            <div class="form-text">ç”¨äºæ–‡ä»¶åŠ å¯†ä¼ è¾“ï¼Œè¯·å¦¥å–„ä¿ç®¡</div>
        </div>
        <div class="d-flex gap-2">
            <button class="btn btn-success flex-grow-1" onclick="rememberKey()">è®°ä½å¯†é’¥</button>
            <button class="btn btn-danger flex-grow-1" onclick="clearKey()">æ¸…é™¤å¯†é’¥</button>
        </div>
    </div>

    <div class="row g-4">
        <div class="col-lg-4">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h5 class="card-title mb-3">ğŸ“¤ ä¸Šä¼ å†…å®¹</h5>

                    <form id="uploadForm" class="mb-4">
                        <div class="mb-3">
                            <label class="form-label">æ–‡å­—å†…å®¹</label>
                            <textarea
                                    id="textInput"
                                    name="text"
                                    class="form-control"
                                    rows="3"
                                    placeholder="è¾“å…¥è¦ä¿å­˜çš„æ–‡å­—..."
                            ></textarea>
                        </div>

                        <div class="mb-3">
                            <label class="form-label">æ–‡ä»¶ä¸Šä¼ </label>
                            <input
                                    type="file"
                                    id="fileInput"
                                    name="file"
                                    class="form-control"
                            >
                        </div>

                        <button type="submit" class="btn btn-primary w-100">
                            <span class="upload-text">å¼€å§‹ä¸Šä¼ </span>
                            <span class="spinner-border spinner-border-sm d-none" role="status"></span>
                        </button>
                    </form>

                    <div
                            id="dropZone"
                            class="card border-dashed bg-light mb-4"
                            style="height: 160px; cursor: pointer;"
                    >
                        <div class="card-body d-flex flex-column justify-content-center text-center text-muted">
                            <div class="drop-zone-text">
                                <i class="bi bi-upload fs-3 mb-2"></i>
                                <div>æ‹–æ”¾æ–‡ä»¶åˆ°æ­¤å¤„ä¸Šä¼ </div>
                                <div class="drop-zone-hint">æˆ–æŒ‰ Ctrl+V ç²˜è´´å›¾ç‰‡</div>
                            </div>
                            <div id="dropPreview" class="d-none">
                                <img id="dropPreviewImage" class="img-fluid rounded mb-2" style="max-height: 100px;">
                                <div>å›¾ç‰‡å·²å‡†å¤‡ä¸Šä¼ </div>
                            </div>
                        </div>
                    </div>

                    <!-- ä¸Šä¼ è¿›åº¦ -->
                    <div id="uploadProgress" class="d-none">
                        <div class="d-flex justify-content-between mb-1">
                            <span>ä¸Šä¼ è¿›åº¦</span>
                            <span id="progressPercent">0%</span>
                        </div>
                        <div class="progress chunk-progress">
                            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                        <div class="mt-2 text-center">
                            <button id="cancelUpload" class="btn btn-sm btn-outline-danger">å–æ¶ˆä¸Šä¼ </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-8">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h5 class="card-title mb-3">ğŸ“‚ æ‰€æœ‰æ–‡ä»¶</h5>
                    <div id="fileList" class="row g-3"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="toast" class="toast align-items-center position-fixed bottom-0 start-50 translate-x-n50 mb-4 border-0"
     role="alert" aria-live="assertive" aria-atomic="true">
    <div class="d-flex bg-dark text-white rounded p-3">
        <div class="toast-body"></div>
        <button type="button" class="btn-close btn-close-white me-3 m-auto" data-bs-dismiss="toast"></button>
    </div>
</div>

<script>
    const MAX_PREVIEW_LENGTH = 1000;
    const CHUNK_SIZE = 5 * 1024 * 1024; // 40MBåˆ†ç‰‡
    let currentUpload = {
        sessionId: null,
        file: null,
        chunks: 0,
        uploaded: 0,
        controller: null,
        isCancelled: false
    };

    class Toast {
        static show(message, type = 'info') {
            const toastEl = document.getElementById('toast');
            const toastBody = toastEl.querySelector('.toast-body');
            const bgClass = type === 'success' ? 'bg-success' : type === 'danger' ? 'bg-danger' : 'bg-dark';
            toastEl.className = `toast show ${bgClass} text-white`;
            toastBody.textContent = message;
            setTimeout(() => toastEl.classList.remove('show'), 3000);
        }
    }

    // å¯†é’¥ç®¡ç†
    function rememberKey() {
        const key = document.getElementById('aesKeyInput').value;
        if (key) {
            localStorage.setItem('aesKey', key);
            Toast.show('å¯†é’¥å·²ä¿å­˜', 'success');
        } else {
            Toast.show('è¯·è¾“å…¥å¯†é’¥', 'danger');
        }
    }

    function clearKey() {
        localStorage.removeItem('aesKey');
        document.getElementById('aesKeyInput').value = '';
        Toast.show('å¯†é’¥å·²æ¸…é™¤', 'success');
    }

    // åˆå§‹åŒ–å¯†é’¥è¾“å…¥æ¡†
    document.addEventListener('DOMContentLoaded', () => {
        const savedKey = localStorage.getItem('aesKey');
        if (savedKey) {
            document.getElementById('aesKeyInput').value = savedKey;
        }
        loadFiles();
    });

    // è·å–å½“å‰å¯†é’¥
    function getAesKey() {
        return document.getElementById('aesKeyInput').value || localStorage.getItem('aesKey') || '';
    }

    // å¯†é’¥æ´¾ç”Ÿå‡½æ•°
    async function deriveKey(password) {
        const encoder = new TextEncoder();
        const passwordBuffer = encoder.encode(password);

        // ä½¿ç”¨å›ºå®šç›å€¼ï¼ˆä¸åç«¯ä¸€è‡´ï¼‰
        const salt = encoder.encode("FixedSaltValue123");

        // å¯¼å…¥å¯†ç ä½œä¸ºåŸå§‹å¯†é’¥
        const baseKey = await crypto.subtle.importKey(
            "raw",
            passwordBuffer,
            { name: "PBKDF2" },
            false,
            ["deriveBits"]
        );

        // ä½¿ç”¨PBKDF2æ´¾ç”Ÿå¯†é’¥
        const derivedBits = await crypto.subtle.deriveBits(
            {
                name: "PBKDF2",
                salt: salt,
                iterations: 65536,
                hash: "SHA-256"
            },
            baseKey,
            256 // 256ä½å¯†é’¥
        );

        // å¯¼å…¥ä¸ºAESå¯†é’¥
        return crypto.subtle.importKey(
            "raw",
            derivedBits,
            { name: "AES-CBC" },
            false,
            ["encrypt", "decrypt"]
        );
    }

    // åŠ å¯†å‡½æ•° - ä¿®å¤ç‰ˆ
    async function encryptChunk(data, password) {
        if (!password) throw new Error('æœªæä¾›AESå¯†é’¥');

        // æ´¾ç”Ÿå¯†é’¥
        const key = await deriveKey(password);

        const iv = crypto.getRandomValues(new Uint8Array(16));
        const encrypted = await crypto.subtle.encrypt(
            { name: "AES-CBC", iv },
            key,
            data
        );

        // å°†IVå‰ç½®åˆ°åŠ å¯†æ•°æ®ä¸­
        const result = new Uint8Array(iv.length + encrypted.byteLength);
        result.set(iv, 0);
        result.set(new Uint8Array(encrypted), iv.length);

        return result;
    }

    // è§£å¯†å‡½æ•° - ä¿®å¤ç‰ˆ
    async function decryptChunk(encryptedData, password) {
        if (!password) throw new Error('æœªæä¾›AESå¯†é’¥');

        const iv = encryptedData.slice(0, 16);
        const ciphertext = encryptedData.slice(16);

        // æ´¾ç”Ÿå¯†é’¥
        const key = await deriveKey(password);

        return crypto.subtle.decrypt(
            { name: "AES-CBC", iv },
            key,
            ciphertext
        );
    }

    // ä¸Šä¼ æ–‡æœ¬
    async function uploadText(text) {
        const key = getAesKey();
        if (!key) {
            Toast.show('è¯·å…ˆè¾“å…¥AESå¯†é’¥', 'danger');
            return;
        }

        try {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const encrypted = await encryptChunk(data, key);

            // è½¬æ¢ä¸ºBase64ä»¥ä¾¿ä¼ è¾“
            const encryptedBase64 = arrayBufferToBase64(encrypted);

            const formData = new FormData();
            formData.append('text', encryptedBase64);

            const response = await fetch('/api/clipboard/uploadText', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) throw new Error('ä¸Šä¼ å¤±è´¥');
            Toast.show('æ–‡æœ¬ä¸Šä¼ æˆåŠŸ', 'success');
            await loadFiles();
        } catch (error) {
            Toast.show(error.message, 'danger');
        }
    }

    // ä¸Šä¼ æ–‡ä»¶ï¼ˆåˆ†ç‰‡ï¼‰
    async function uploadFile(file) {
        const key = getAesKey();
        if (!key) {
            Toast.show('è¯·å…ˆè¾“å…¥AESå¯†é’¥', 'danger');
            return;
        }

        // åˆå§‹åŒ–ä¸Šä¼ çŠ¶æ€
        currentUpload = {
            sessionId: generateUUID(),
            file: file,
            chunks: Math.ceil(file.size / CHUNK_SIZE),
            uploaded: 0,
            controller: new AbortController(),
            isCancelled: false
        };

        // æ˜¾ç¤ºè¿›åº¦
        document.getElementById('uploadProgress').classList.remove('d-none');
        updateProgress();

        try {
            // æ£€æŸ¥å·²ä¸Šä¼ çš„åˆ†ç‰‡
            const response = await fetch(`/api/clipboard/checkChunks/${currentUpload.sessionId}`);
            const uploadedChunks = response.ok ? await response.json() : [];

            // ä¸Šä¼ æ‰€æœ‰åˆ†ç‰‡
            for (let i = 0; i < currentUpload.chunks; i++) {
                if (currentUpload.isCancelled) break;

                // è·³è¿‡å·²ä¸Šä¼ çš„åˆ†ç‰‡
                if (uploadedChunks.includes(i)) {
                    currentUpload.uploaded++;
                    updateProgress();
                    continue;
                }

                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.size);
                const chunk = file.slice(start, end);

                // åŠ å¯†åˆ†ç‰‡
                const encrypted = await encryptChunk(await chunk.arrayBuffer(), key);

                // åˆ›å»ºFormData
                const formData = new FormData();
                formData.append('sessionId', currentUpload.sessionId);
                formData.append('chunkIndex', i.toString());
                formData.append('totalChunks', currentUpload.chunks.toString());
                formData.append('fileName', file.name);
                formData.append('data', new Blob([encrypted]));

                // ä¸Šä¼ åˆ†ç‰‡
                await fetch('/api/clipboard/uploadChunk', {
                    method: 'POST',
                    body: formData,
                    signal: currentUpload.controller.signal
                });

                currentUpload.uploaded++;
                updateProgress();
            }

            if (currentUpload.isCancelled) {
                Toast.show('ä¸Šä¼ å·²å–æ¶ˆ', 'warning');
            } else {
                Toast.show('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ', 'success');
                await loadFiles();
            }
        } catch (error) {
            if (error.name !== 'AbortError') {
                Toast.show(`ä¸Šä¼ å¤±è´¥: ${error.message}`, 'danger');
            }
        } finally {
            // é‡ç½®ä¸Šä¼ çŠ¶æ€
            document.getElementById('uploadProgress').classList.add('d-none');
            currentUpload = {
                sessionId: null,
                file: null,
                chunks: 0,
                uploaded: 0,
                controller: null,
                isCancelled: false
            };
        }
    }

    // ä¸‹è½½æ–‡ä»¶ - ä¿®å¤ç‰ˆ
    async function downloadFile(fileName) {
        const key = getAesKey();
        if (!key) {
            Toast.show('è¯·å…ˆè¾“å…¥AESå¯†é’¥', 'danger');
            return;
        }

        try {
            const response = await fetch(`/api/clipboard/files/${encodeURIComponent(fileName)}`);
            if (!response.ok) throw new Error('ä¸‹è½½å¤±è´¥');

            const encryptedData = await response.arrayBuffer();

            // è§£å¯†å†…å®¹
            const decrypted = await decryptChunk(new Uint8Array(encryptedData), key);

            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const blob = new Blob([decrypted]);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();

            // æ¸…ç†
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);

            Toast.show('æ–‡ä»¶ä¸‹è½½æˆåŠŸ', 'success');
        } catch (error) {
            Toast.show(`ä¸‹è½½å¤±è´¥: ${error.message}`, 'danger');
        }
    }

    // æ›´æ–°ä¸Šä¼ è¿›åº¦
    function updateProgress() {
        const percent = Math.round((currentUpload.uploaded / currentUpload.chunks) * 100);
        document.getElementById('progressBar').style.width = `${percent}%`;
        document.getElementById('progressPercent').textContent = `${percent}%`;
    }

    // å–æ¶ˆä¸Šä¼ 
    document.getElementById('cancelUpload').addEventListener('click', () => {
        if (currentUpload.controller) {
            currentUpload.controller.abort();
            currentUpload.isCancelled = true;
        }
    });

    // åŠ è½½æ–‡ä»¶åˆ—è¡¨
    async function loadFiles() {
        try {
            const response = await fetch('/api/clipboard/queryAllFiles');
            const files = await response.json();
            renderFiles(files);
            loadTextContents(files);
        } catch (error) {
            Toast.show('åŠ è½½æ–‡ä»¶å¤±è´¥', 'danger');
        }
    }

    function renderFiles(files) {
        const container = document.getElementById('fileList');
        container.innerHTML = files.map(file => `
        <div class="col-12">
            <div class="card file-card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center">
                        <img src="${file.isWhitelisted ?
            'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGViZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSIjMjhhNzQ1Ij48cGF0aCBkPSJNMTkuMjkzIDUuMjkzTDkgMTUuNTg2IDQuNzA3IDExLjI5MyAzLjI5MyAxMi43MDcgOSAxOC40MTQgMjAuNzA3IDYuNzA3eiIvPjwvc3ZnPg==' :
            'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSIjNmM3NTgwIj48cGF0aCBkPSJNMTkgNWgydjE0aC0ydjE0SDU2djJIMThWN0g1VjVoMTR6TTMxIDE5VjVoMTR2MThIMzF6Ii8+PC9zdmc+'}"
                             class="whitelist-icon">
                        <span class="ms-2">${file.fileName}</span>
                    </div>
                    <small class="text-muted">
                        ${new Date(file.creationTime).toLocaleDateString()}
                    </small>
                </div>
                <div class="card-body">
                    ${file.type === 'text' ? `
                        <div class="content-preview">
                            <div class="text-content-wrapper">
                                <div class="pre-line-container" id="pre-${encodeURIComponent(file.fileName)}">
                                    <div class="d-flex align-items-center text-muted">
                                        <div class="spinner-border spinner-border-sm me-2"></div>
                                        æ­£åœ¨åŠ è½½å†…å®¹...
                                    </div>
                                </div>
                            </div>
                        </div>
                    ` : file.type === 'image' ? `
                        <img src="/api/clipboard/files/${encodeURIComponent(file.fileName)}"
                             class="img-fluid rounded"
                             loading="lazy">
                    ` : `
                        <button class="btn btn-outline-primary w-100"
                                onclick="downloadFile('${encodeURIComponent(file.fileName)}')"
                                title="ä¸‹è½½æ–‡ä»¶">
                            ä¸‹è½½æ–‡ä»¶
                        </button>
                    `}
                </div>
                <div class="card-footer d-flex justify-content-between">
                    <button class="btn ${file.isWhitelisted ? 'btn-danger' : 'btn-success'}"
                            onclick="toggleWhitelist('${encodeURIComponent(file.fileName)}', ${!file.isWhitelisted})">
                        ${file.isWhitelisted ? 'ç§»å‡ºç™½åå•' : 'åŠ å…¥ä¿æŠ¤'}
                    </button>
                    <button class="btn btn-outline-danger"
                            onclick="deleteFile('${encodeURIComponent(file.fileName)}')">
                        åˆ é™¤
                    </button>
                </div>
            </div>
        </div>
        `).join('');
    }

    // åŠ è½½æ–‡æœ¬å†…å®¹ - ä¿®å¤ç‰ˆ
    async function loadTextContents(files) {
        const textFiles = files.filter(f => f.type === 'text');

        for (const file of textFiles) {
            const encodedFileName = encodeURIComponent(file.fileName);
            const containerId = `pre-${encodedFileName}`;
            const container = document.getElementById(containerId);

            if (!container) {
                console.error(`æ‰¾ä¸åˆ°å®¹å™¨: ${containerId}`);
                continue;
            }

            try {
                // æ˜¾ç¤ºåŠ è½½ä¸­
                container.innerHTML = `
                    <div class="d-flex align-items-center text-muted">
                        <div class="spinner-border spinner-border-sm me-2"></div>
                        æ­£åœ¨åŠ è½½å†…å®¹...
                    </div>
                `;

                const response = await fetch(`/api/clipboard/files/${encodedFileName}`);
                if (!response.ok) throw new Error(`HTTPé”™è¯¯: ${response.status}`);

                // è·å–ArrayBuffer
                const encryptedData = await response.arrayBuffer();

                // è·å–å¯†é’¥
                const key = getAesKey();
                if (!key) {
                    throw new Error('æœªæä¾›AESå¯†é’¥');
                }

                // è§£å¯†
                const decrypted = await decryptChunk(new Uint8Array(encryptedData), key);
                const decoder = new TextDecoder();
                const content = decoder.decode(decrypted);

                // å­˜å‚¨åŸå§‹å†…å®¹ç”¨äºå¤åˆ¶
                container.dataset.fullContent = content;

                // æ ¹æ®å†…å®¹é•¿åº¦å†³å®šæ˜¾ç¤ºæ–¹å¼
                if (content.length > MAX_PREVIEW_LENGTH) {
                    container.innerHTML = `
                        <div class="text-content-wrapper">
                            <div class="pre-line" style="max-height:200px;overflow:hidden;">
                                ${escapeHtml(content)}
                            </div>
                            <button class="copy-btn" onclick="copyTextContent('${encodedFileName}', this)" title="å¤åˆ¶å†…å®¹">
                                å¤åˆ¶
                            </button>
                            <button class="btn btn-link p-0 mt-2 show-full-btn"
                                    onclick="toggleExpand('${encodedFileName}')">
                                æ˜¾ç¤ºå®Œæ•´å†…å®¹
                            </button>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="text-content-wrapper">
                            <div class="pre-line">
                                ${escapeHtml(content)}
                            </div>
                            <button class="copy-btn" onclick="copyTextContent('${encodedFileName}', this)" title="å¤åˆ¶å†…å®¹">
                                å¤åˆ¶
                            </button>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('å†…å®¹åŠ è½½å¤±è´¥:', error);
                container.innerHTML = `
                    <div class="text-danger">
                        åŠ è½½å¤±è´¥: ${error.message}
                        <button class="btn btn-link p-0"
                                onclick="loadTextContents([${JSON.stringify(file)}])">
                            é‡è¯•
                        </button>
                    </div>
                `;
            }
        }
    }

    // å¤åˆ¶æ–‡æœ¬å†…å®¹åŠŸèƒ½
    async function copyTextContent(encodedFileName, buttonElement) {
        try {
            const container = document.getElementById(`pre-${encodedFileName}`);
            if (!container) {
                Toast.show('æ‰¾ä¸åˆ°å†…å®¹', 'danger');
                return;
            }

            const content = container.dataset.fullContent;
            if (!content) {
                Toast.show('å†…å®¹æœªåŠ è½½', 'danger');
                return;
            }

            // ä½¿ç”¨ç°ä»£Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(content);
                Toast.show('å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
            } else {
                // é™çº§æ–¹æ¡ˆ
                const textArea = document.createElement('textarea');
                textArea.value = content;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();

                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        Toast.show('å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                    } else {
                        throw new Error('å¤åˆ¶å‘½ä»¤å¤±è´¥');
                    }
                } catch (err) {
                    Toast.show('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬å¤åˆ¶', 'danger');
                }

                document.body.removeChild(textArea);
            }

            // æ·»åŠ å¤åˆ¶æˆåŠŸè§†è§‰æ•ˆæœ
            if (buttonElement) {
                const originalText = buttonElement.textContent;
                const originalClass = buttonElement.className;

                buttonElement.textContent = 'å·²å¤åˆ¶!';
                buttonElement.className = originalClass + ' copy-success';

                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.className = originalClass;
                }, 2000);
            }
        } catch (error) {
            console.error('å¤åˆ¶å¤±è´¥:', error);
            Toast.show('å¤åˆ¶å¤±è´¥: ' + error.message, 'danger');
        }
    }

    function toggleExpand(filename) {
        const encoded = encodeURIComponent(filename);
        const container = document.querySelector(`#pre-${CSS.escape(encoded)} .pre-line`);
        const button = document.querySelector(`#pre-${CSS.escape(encoded)} .show-full-btn`);
        if (container) {
            if (container.style.maxHeight === '200px' || !container.style.maxHeight) {
                container.style.maxHeight = 'none';
                if (button) button.textContent = 'æ”¶èµ·å†…å®¹';
            } else {
                container.style.maxHeight = '200px';
                if (button) button.textContent = 'æ˜¾ç¤ºå®Œæ•´å†…å®¹';
            }
        }
    }

    function escapeHtml(unsafe) {
        return unsafe.replace(/[&<"'>]/g, m => ({
            '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
        }[m]));
    }

    async function toggleWhitelist(filename, addToWhitelist) {
        if (!confirm(`ç¡®å®šè¦${addToWhitelist ? 'åŠ å…¥' : 'ç§»å‡º'}ç™½åå•å—ï¼Ÿ`)) return;
        try {
            const response = await fetch(`/api/clipboard/whitelist/${filename}?addToWhitelist=${addToWhitelist}`, {
                method: 'PUT'
            });
            if (response.ok) {
                Toast.show(`å·²${addToWhitelist ? 'åŠ å…¥' : 'ç§»å‡º'}ç™½åå•`, 'success');
                await loadFiles();
            }
        } catch {
            Toast.show('æ“ä½œå¤±è´¥', 'danger');
        }
    }

    async function deleteFile(filename) {
        if (!confirm('ç¡®å®šè¦æ°¸ä¹…åˆ é™¤æ­¤æ–‡ä»¶å—ï¼Ÿ')) return;
        try {
            const response = await fetch(`/api/clipboard/deleteFile/${filename}`, {
                method: 'DELETE'
            });
            if (response.ok) {
                Toast.show('æ–‡ä»¶å·²åˆ é™¤', 'success');
                await loadFiles();
            }
        } catch {
            Toast.show('åˆ é™¤å¤±è´¥', 'danger');
        }
    }

    // è¾…åŠ©å‡½æ•°
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('uploadForm').addEventListener('submit', async e => {
            e.preventDefault();

            const text = document.getElementById('textInput').value;
            const fileInput = document.getElementById('fileInput');

            if (text) {
                await uploadText(text);
            } else if (fileInput.files.length > 0) {
                await uploadFile(fileInput.files[0]);
            } else {
                Toast.show('è¯·æä¾›æ–‡æœ¬æˆ–æ–‡ä»¶', 'warning');
            }

            e.target.reset();
        });

        const dropZone = document.getElementById('dropZone');
        const dropPreview = document.getElementById('dropPreview');
        const dropPreviewImage = document.getElementById('dropPreviewImage');
        const dropZoneText = document.querySelector('.drop-zone-text');

        // å¤„ç†æ‹–æ”¾äº‹ä»¶
        dropZone.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', async e => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            if (e.dataTransfer.files.length) {
                await uploadFile(e.dataTransfer.files[0]);
            }
        });

        // å¤„ç†ç²˜è´´äº‹ä»¶
        document.addEventListener('paste', async (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    const file = new File([blob], 'ç²˜è´´çš„å›¾ç‰‡.png', { type: 'image/png' });

                    // æ˜¾ç¤ºé¢„è§ˆ
                    const objectUrl = URL.createObjectURL(blob);
                    dropPreviewImage.src = objectUrl;
                    dropZoneText.classList.add('d-none');
                    dropPreview.classList.remove('d-none');

                    // ä¸Šä¼ å›¾ç‰‡
                    await uploadFile(file);

                    // é‡ç½®é¢„è§ˆ
                    setTimeout(() => {
                        dropPreview.classList.add('d-none');
                        dropZoneText.classList.remove('d-none');
                        URL.revokeObjectURL(objectUrl);
                    }, 2000);

                    break;
                }
            }
        });
    });
</script>
</body>
</html>